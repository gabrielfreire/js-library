/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function User(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

User.prototype.getFirstName = function() {
    return this.firstName;
}

User.prototype.getLastName = function() {
    return this.lastName;
}

User.prototype.getFullName = function() {
    return this.firstName + ' ' + this.lastName;
}

//export User module
module.exports = User;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * In this file i use my library to test its features
 */
var User = __webpack_require__(0),
    users = [],
    user = new User("Bob", "Marley"),
    user2 = new User("Maria", 'Jose'),
    user3 = new User("John", "McCartney"),
    user4 = new User("Claire", "Murray"),
    content = document.getElementById("content"),
    m = ml();

users.push(user);
users.push(user2);
users.push(user3);
users.push(user4);

console.log(m);
//testing max method
var maxValue = m.max([9, 1, 3, 4, 2, 1, 320, 45, 31, 123, 5, 12332, 12, 32, 156, 776, 4])
console.log(maxValue);
//testing mapToElement
m.mapToElement(users, content);
//testing log
for (var i = 0; i < users.length; i++) {
    m.log(users[i].getFullName());
}
m.log();
//Testing routes
m.router([{
        path: '/',
        name: 'Home',
        templateUrl: '../partials/home.html'
    },
    {
        path: '/about',
        name: 'About',
        template: '<h1>This is the About Page</h1>'
    },
    {
        path: '/contact',
        name: 'Contact',
        template: '<h1>This is the Contact Page</h1>'
    }
]);
//Data Binding object
var values = {
    name: 'Gabriel',
    age: 27,
    surname: 'Freire'
}

m.bind(values);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

(function(global) {
    /**
     * Extremely simple and dump mini library for study purposes only
     * Feel free to add features and maybe transform it in something great/useful some day
     */
    "use strict";
    //---------------------------
    //Global variable declarations
    //---------------------------
    //Default view for the router feature
    var view = document.querySelector('[lib-view]') || '',
        binders = Array.from(document.querySelectorAll('[lib-bind]')),
        models = Array.from(document.querySelectorAll('[lib-model]')),
        //new an Object
        myLib = function(ar) { return new myLib.init(ar); },
        Router = function(routes) { this.routes = routes; };

    //---------------------------
    //General METHODS
    //---------------------------
    //This method will change the browse location path to match with the attribute value of the button
    function _navigate(event) {
        console.log(event.target.attributes);
        //get the current path  global = window
        var currentPath = global.location.pathname,
            //get the attribute value of the current button
            route = event.target.attributes['lib-route'].value,
            //compare it with the array of routes to find
            routeInfo = router.routes.filter(function(r) {
                return r.path === route;
            })[0];

        //if no route was found, 404 page
        if (!routeInfo) {

            global.history.pushState({}, '404 not found', '404');
            view.innerHTML = 'No route with this path name';
            if (routeInfo.templateUrl) {
                _getTemplate(routeInfo.templateUrl, function(content) {
                    view.innerHTML = content;
                });
            } else {
                view.innerHTML += routeInfo.template;
            }
        } else {
            //else, push state to the browser and render the right template
            global.history.pushState({}, routeInfo.name, routeInfo.path);
            _setActive(routeInfo.path);
            view.innerHTML = 'You clicked ' + routeInfo.name + ' route';
            if (routeInfo.templateUrl) {
                _getTemplate(routeInfo.templateUrl, function(content) {
                    view.innerHTML = content;
                });
            } else {
                view.innerHTML += routeInfo.template;
            }

        }
    };

    //Method to set active class to a specific route
    function _setActive(route) {
        //get all the buttons/links that contain lib-route attribute
        var activeRoutes = Array.from(document.querySelectorAll('[lib-route]'));

        activeRoutes.forEach(function(activeRoute) {
            //Get the current route and current class from each button/link
            var currentRoute = activeRoute.attributes['lib-route'].value;
            //if the current route is the same as the one passed by parameter, set class to Active
            if (currentRoute === route) {

                activeRoute.classList.add('active');

            } else {
                //otherwise set the class back to the current class
                activeRoute.classList.remove('active');

            }
        });
    }

    function _fileExists(content) {
        if (content.substr(0, 6) === '<html>') {
            return false;
        } else {
            return true;
        }
    }

    function _getTemplate(path, callbackSuccess, callBackError) {
        var request = new XMLHttpRequest();

        request.open('GET', path, true);

        request.send(null);

        request.onreadystatechange = function(event) {
            if (request.readyState === 4) {
                var exist = _fileExists(request.responseText);
                if (!exist) {
                    if (callBackError) {
                        callBackError(request.statusText);
                        throw Error('Template URL ' + path + ' was not found.');
                    } else {
                        throw Error('Template URL ' + path + ' was not found.');
                    }
                }
                if (request.status === 200) {
                    callbackSuccess(request.responseText);
                }
            }
        };


    }
    //this method receives a path and match with the routes array
    function _matchWithPath(currentPath) {
        var route = router.routes.filter(function(r) { return r.path === currentPath; })[0];
        return route;
    }
    //this method will return true if the content in HTML is a string interpolation binder 
    function _isBinder(content) {
        return content.indexOf('{') > -1 && content.lastIndexOf('}') > -1;
    }
    //Event method triggered when the user types something in a lib-model field
    function _changeContent(event) {
        var value = event.target.value,
            attrValue = event.target.attributes['lib-model'].value,
            found = false;

        if (binders.length <= 0) {
            throw new Error('There are no binders');
        }

        for (var i = 0; i < binders.length; i++) {
            var binderAttrValue = binders[i].attributes['lib-bind'].value;

            if (binderAttrValue === attrValue) {

                found = true;
                binders[i].textContent = value;

            }
        }

        if (!found) {
            throw new Error('There are no binders with {' + attrValue + '} name');
        }
    }
    //------------------------
    //myLib PROTOTYPE functions
    //------------------------
    myLib.prototype = {
        /**
         * Data bind feature: receives an object from the controller and sync its properties with the bind elements
         */
        bind: function(values) {
            //if there are any input field lib-model, attach an event to change a lib-binder content
            if (models) {

                models.forEach(function(model) {
                    model.addEventListener('keyup', _changeContent, false);
                });

            }

            for (var properties in values) {

                for (var i = 0; i < binders.length; i++) {
                    var binderValue = _isBinder(binders[i].textContent) ? binders[i].textContent.slice(1, binders[i].textContent.lastIndexOf('}')) : null;

                    if (properties === binderValue) {
                        binders[i].textContent = values[properties];
                    }

                }

            }
        },
        /**
         * Method that creates a router
         * @param r: routes array
         * /**
         * Routes structure  
         * [
         *  {
         *     path: '/',
         *     name: 'Home',
         *     template: '<p>Home route</p>'
         *  },
         *  {
         *     path: '/contact',
         *     name: 'Contact',
         *     template: '<p>Home route</p>'
         *  }
         * ]
         */
        router: function(routes) {
            //get the current path  global = window
            var currentPath = global.location.pathname,
                //capture all the buttons with route attributes
                activeRoutes = Array.from(document.querySelectorAll('[lib-route]'));
            //create a new Router object
            global.router = new Router(routes);
            //if there are any buttons, add an Event listener to each one of them
            if (activeRoutes.length > 0) {

                activeRoutes.forEach(function(activeRoute) {
                    activeRoute.addEventListener('click', _navigate, false);
                });

            } else {
                //if not, log for debugging purposes
                myLib.prototype.log('No route attribute found!');

            }
            //If the current path is '/' ... render the Home template
            if (currentPath === '/') {
                //use filter feature to get the current template according to the current path
                var route = _matchWithPath(currentPath);
                _setActive(route.path);
                if (route.templateUrl) {
                    _getTemplate(route.templateUrl, function(content) {
                        view.innerHTML = content;
                    }, function(err) {
                        console.error('An error has occured ', err);
                    });
                } else {
                    view.innerHTML += route.template;
                }

            } else {
                //Else look for the right path and render the correct template
                var route = _matchWithPath(currentPath);
                _setActive(route.path);
                view.innerHTML = '<strong>' + currentPath + ' ' + route.name + ' route</strong>'
                if (route.templateUrl) {
                    _getTemplate(route.templateUrl, function(content) {
                        view.innerHTML = content;
                    }, function(err) {
                        console.error('An error has occured ', err);
                    });
                } else {
                    view.innerHTML += route.template;
                }
            }
        },
        /**
         * Map through an array and build an <h3> element for every index
         * @param {array} ar 
         */
        mapToElement: function(ar, element) {
            //If no array is found, throw an error
            if (!ar) {
                throw Error('Array does not exist!');
            }
            if (!element) {
                throw Error('No Element was passed');
            }
            //Traverse array to map
            for (var i = 0; i < ar.length; i++) {
                //check if the actual element is an User object
                if (ar[i] instanceof Object) {
                    //print key values and its properties
                    element.innerHTML += '<h3>Object: </h3>';
                    for (var prop in ar[i]) {
                        element.innerHTML += '<h5>' + prop + ': ' + ar[prop] + '</h5>';
                    }
                } else {
                    //if it isn't an User object, just print the element itself
                    element.innerHTML += '<h3>' + ar[i] + '</h3>';
                }
            }
        },
        /**
         * Return the maximum value of a given array
         * @param ar : Array Object
         */
        max: function(ar) {
            var max = ar[0],
                //get any element with ID #content
                content = document.getElementById("content") || null;
            //traverse the array to find the maximum value
            for (var i = 0; i < ar.length; i++) {
                //if the index element is not a number, throw an error
                if (typeof ar[i] !== 'number') {
                    throw 'There are non number elements in the array!';
                } else {
                    //check if the maximum value is lower than the actual value
                    if (max < ar[i]) {
                        max = ar[i] //set maximum
                    }
                }
            }
            if (content) {
                //add a representation for the array to the HTML
                content.innerHTML += '<strong>The maximum number from the array: ' + ar + ' is: ' + max + '</strong>'
            }
            return max; // return the value
        },
        /**
         * Log method
         */
        log: function(content) {
            console.warn('>>');
            if (content) {
                if (typeof content === 'object') {
                    for (var prop in content) {
                        if (typeof prop !== 'object') {
                            console.log(prop + ': ' + content[prop]);
                        }
                    }
                } else
                    console.log('-> ' + content);
            } else {
                //If no array or string is found, throw an error
                console.error('No content!');
            }
            console.warn('<<');
        }

    };

    //Constructor function for the library
    myLib.init = function(ar) {

        var self = this;
        self.ar = ar || null;

    }

    //Borrowing the myLib prototype for the myLib.init prototype
    myLib.init.prototype = myLib.prototype;
    //Making it global for external use
    global.myLib = global.ml = myLib;


})(window);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(2);
__webpack_require__(1);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmYxZmQ5NjQxYmE2M2RlNjc4ZTUiLCJ3ZWJwYWNrOi8vLy4vanMvVXNlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2pzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vanMvc2NyaXB0cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQjs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLFU7Ozs7OztBQ2pWRDtBQUNBO0FBQ0EsdUIiLCJmaWxlIjoic2NyaXB0cy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGZmMWZkOTY0MWJhNjNkZTY3OGU1IiwiZnVuY3Rpb24gVXNlcihmaXJzdE5hbWUsIGxhc3ROYW1lKSB7XHJcbiAgICB0aGlzLmZpcnN0TmFtZSA9IGZpcnN0TmFtZTtcclxuICAgIHRoaXMubGFzdE5hbWUgPSBsYXN0TmFtZTtcclxufVxyXG5cclxuVXNlci5wcm90b3R5cGUuZ2V0Rmlyc3ROYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maXJzdE5hbWU7XHJcbn1cclxuXHJcblVzZXIucHJvdG90eXBlLmdldExhc3ROYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sYXN0TmFtZTtcclxufVxyXG5cclxuVXNlci5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmZpcnN0TmFtZSArICcgJyArIHRoaXMubGFzdE5hbWU7XHJcbn1cclxuXHJcbi8vZXhwb3J0IFVzZXIgbW9kdWxlXHJcbm1vZHVsZS5leHBvcnRzID0gVXNlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL1VzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEluIHRoaXMgZmlsZSBpIHVzZSBteSBsaWJyYXJ5IHRvIHRlc3QgaXRzIGZlYXR1cmVzXHJcbiAqL1xyXG52YXIgVXNlciA9IHJlcXVpcmUoJy4vVXNlci5qcycpLFxyXG4gICAgdXNlcnMgPSBbXSxcclxuICAgIHVzZXIgPSBuZXcgVXNlcihcIkJvYlwiLCBcIk1hcmxleVwiKSxcclxuICAgIHVzZXIyID0gbmV3IFVzZXIoXCJNYXJpYVwiLCAnSm9zZScpLFxyXG4gICAgdXNlcjMgPSBuZXcgVXNlcihcIkpvaG5cIiwgXCJNY0NhcnRuZXlcIiksXHJcbiAgICB1c2VyNCA9IG5ldyBVc2VyKFwiQ2xhaXJlXCIsIFwiTXVycmF5XCIpLFxyXG4gICAgY29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udGVudFwiKSxcclxuICAgIG0gPSBtbCgpO1xyXG5cclxudXNlcnMucHVzaCh1c2VyKTtcclxudXNlcnMucHVzaCh1c2VyMik7XHJcbnVzZXJzLnB1c2godXNlcjMpO1xyXG51c2Vycy5wdXNoKHVzZXI0KTtcclxuXHJcbmNvbnNvbGUubG9nKG0pO1xyXG4vL3Rlc3RpbmcgbWF4IG1ldGhvZFxyXG52YXIgbWF4VmFsdWUgPSBtLm1heChbOSwgMSwgMywgNCwgMiwgMSwgMzIwLCA0NSwgMzEsIDEyMywgNSwgMTIzMzIsIDEyLCAzMiwgMTU2LCA3NzYsIDRdKVxyXG5jb25zb2xlLmxvZyhtYXhWYWx1ZSk7XHJcbi8vdGVzdGluZyBtYXBUb0VsZW1lbnRcclxubS5tYXBUb0VsZW1lbnQodXNlcnMsIGNvbnRlbnQpO1xyXG4vL3Rlc3RpbmcgbG9nXHJcbmZvciAodmFyIGkgPSAwOyBpIDwgdXNlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgIG0ubG9nKHVzZXJzW2ldLmdldEZ1bGxOYW1lKCkpO1xyXG59XHJcbm0ubG9nKCk7XHJcbi8vVGVzdGluZyByb3V0ZXNcclxubS5yb3V0ZXIoW3tcclxuICAgICAgICBwYXRoOiAnLycsXHJcbiAgICAgICAgbmFtZTogJ0hvbWUnLFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnLi4vcGFydGlhbHMvaG9tZS5odG1sJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBwYXRoOiAnL2Fib3V0JyxcclxuICAgICAgICBuYW1lOiAnQWJvdXQnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnPGgxPlRoaXMgaXMgdGhlIEFib3V0IFBhZ2U8L2gxPidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgcGF0aDogJy9jb250YWN0JyxcclxuICAgICAgICBuYW1lOiAnQ29udGFjdCcsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8aDE+VGhpcyBpcyB0aGUgQ29udGFjdCBQYWdlPC9oMT4nXHJcbiAgICB9XHJcbl0pO1xyXG4vL0RhdGEgQmluZGluZyBvYmplY3RcclxudmFyIHZhbHVlcyA9IHtcclxuICAgIG5hbWU6ICdHYWJyaWVsJyxcclxuICAgIGFnZTogMjcsXHJcbiAgICBzdXJuYW1lOiAnRnJlaXJlJ1xyXG59XHJcblxyXG5tLmJpbmQodmFsdWVzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2NvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyZW1lbHkgc2ltcGxlIGFuZCBkdW1wIG1pbmkgbGlicmFyeSBmb3Igc3R1ZHkgcHVycG9zZXMgb25seVxyXG4gICAgICogRmVlbCBmcmVlIHRvIGFkZCBmZWF0dXJlcyBhbmQgbWF5YmUgdHJhbnNmb3JtIGl0IGluIHNvbWV0aGluZyBncmVhdC91c2VmdWwgc29tZSBkYXlcclxuICAgICAqL1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9HbG9iYWwgdmFyaWFibGUgZGVjbGFyYXRpb25zXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9EZWZhdWx0IHZpZXcgZm9yIHRoZSByb3V0ZXIgZmVhdHVyZVxyXG4gICAgdmFyIHZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbbGliLXZpZXddJykgfHwgJycsXHJcbiAgICAgICAgYmluZGVycyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2xpYi1iaW5kXScpKSxcclxuICAgICAgICBtb2RlbHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsaWItbW9kZWxdJykpLFxyXG4gICAgICAgIC8vbmV3IGFuIE9iamVjdFxyXG4gICAgICAgIG15TGliID0gZnVuY3Rpb24oYXIpIHsgcmV0dXJuIG5ldyBteUxpYi5pbml0KGFyKTsgfSxcclxuICAgICAgICBSb3V0ZXIgPSBmdW5jdGlvbihyb3V0ZXMpIHsgdGhpcy5yb3V0ZXMgPSByb3V0ZXM7IH07XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vR2VuZXJhbCBNRVRIT0RTXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9UaGlzIG1ldGhvZCB3aWxsIGNoYW5nZSB0aGUgYnJvd3NlIGxvY2F0aW9uIHBhdGggdG8gbWF0Y2ggd2l0aCB0aGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBidXR0b25cclxuICAgIGZ1bmN0aW9uIF9uYXZpZ2F0ZShldmVudCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzKTtcclxuICAgICAgICAvL2dldCB0aGUgY3VycmVudCBwYXRoICBnbG9iYWwgPSB3aW5kb3dcclxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSBnbG9iYWwubG9jYXRpb24ucGF0aG5hbWUsXHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgYnV0dG9uXHJcbiAgICAgICAgICAgIHJvdXRlID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXNbJ2xpYi1yb3V0ZSddLnZhbHVlLFxyXG4gICAgICAgICAgICAvL2NvbXBhcmUgaXQgd2l0aCB0aGUgYXJyYXkgb2Ygcm91dGVzIHRvIGZpbmRcclxuICAgICAgICAgICAgcm91dGVJbmZvID0gcm91dGVyLnJvdXRlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIucGF0aCA9PT0gcm91dGU7XHJcbiAgICAgICAgICAgIH0pWzBdO1xyXG5cclxuICAgICAgICAvL2lmIG5vIHJvdXRlIHdhcyBmb3VuZCwgNDA0IHBhZ2VcclxuICAgICAgICBpZiAoIXJvdXRlSW5mbykge1xyXG5cclxuICAgICAgICAgICAgZ2xvYmFsLmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnNDA0IG5vdCBmb3VuZCcsICc0MDQnKTtcclxuICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgPSAnTm8gcm91dGUgd2l0aCB0aGlzIHBhdGggbmFtZSc7XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8udGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAgICAgICAgIF9nZXRUZW1wbGF0ZShyb3V0ZUluZm8udGVtcGxhdGVVcmwsIGZ1bmN0aW9uKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuaW5uZXJIVE1MICs9IHJvdXRlSW5mby50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vZWxzZSwgcHVzaCBzdGF0ZSB0byB0aGUgYnJvd3NlciBhbmQgcmVuZGVyIHRoZSByaWdodCB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICBnbG9iYWwuaGlzdG9yeS5wdXNoU3RhdGUoe30sIHJvdXRlSW5mby5uYW1lLCByb3V0ZUluZm8ucGF0aCk7XHJcbiAgICAgICAgICAgIF9zZXRBY3RpdmUocm91dGVJbmZvLnBhdGgpO1xyXG4gICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9ICdZb3UgY2xpY2tlZCAnICsgcm91dGVJbmZvLm5hbWUgKyAnIHJvdXRlJztcclxuICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgX2dldFRlbXBsYXRlKHJvdXRlSW5mby50ZW1wbGF0ZVVybCwgZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW5uZXJIVE1MID0gY29udGVudDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgKz0gcm91dGVJbmZvLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy9NZXRob2QgdG8gc2V0IGFjdGl2ZSBjbGFzcyB0byBhIHNwZWNpZmljIHJvdXRlXHJcbiAgICBmdW5jdGlvbiBfc2V0QWN0aXZlKHJvdXRlKSB7XHJcbiAgICAgICAgLy9nZXQgYWxsIHRoZSBidXR0b25zL2xpbmtzIHRoYXQgY29udGFpbiBsaWItcm91dGUgYXR0cmlidXRlXHJcbiAgICAgICAgdmFyIGFjdGl2ZVJvdXRlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2xpYi1yb3V0ZV0nKSk7XHJcblxyXG4gICAgICAgIGFjdGl2ZVJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGl2ZVJvdXRlKSB7XHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBjdXJyZW50IHJvdXRlIGFuZCBjdXJyZW50IGNsYXNzIGZyb20gZWFjaCBidXR0b24vbGlua1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdXRlID0gYWN0aXZlUm91dGUuYXR0cmlidXRlc1snbGliLXJvdXRlJ10udmFsdWU7XHJcbiAgICAgICAgICAgIC8vaWYgdGhlIGN1cnJlbnQgcm91dGUgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSBwYXNzZWQgYnkgcGFyYW1ldGVyLCBzZXQgY2xhc3MgdG8gQWN0aXZlXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Um91dGUgPT09IHJvdXRlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYWN0aXZlUm91dGUuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9vdGhlcndpc2Ugc2V0IHRoZSBjbGFzcyBiYWNrIHRvIHRoZSBjdXJyZW50IGNsYXNzXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSb3V0ZS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZmlsZUV4aXN0cyhjb250ZW50KSB7XHJcbiAgICAgICAgaWYgKGNvbnRlbnQuc3Vic3RyKDAsIDYpID09PSAnPGh0bWw+Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRUZW1wbGF0ZShwYXRoLCBjYWxsYmFja1N1Y2Nlc3MsIGNhbGxCYWNrRXJyb3IpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xyXG5cclxuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gX2ZpbGVFeGlzdHMocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsQmFja0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxCYWNrRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RlbXBsYXRlIFVSTCAnICsgcGF0aCArICcgd2FzIG5vdCBmb3VuZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGUgVVJMICcgKyBwYXRoICsgJyB3YXMgbm90IGZvdW5kLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTdWNjZXNzKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgIH1cclxuICAgIC8vdGhpcyBtZXRob2QgcmVjZWl2ZXMgYSBwYXRoIGFuZCBtYXRjaCB3aXRoIHRoZSByb3V0ZXMgYXJyYXlcclxuICAgIGZ1bmN0aW9uIF9tYXRjaFdpdGhQYXRoKGN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVyLnJvdXRlcy5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gci5wYXRoID09PSBjdXJyZW50UGF0aDsgfSlbMF07XHJcbiAgICAgICAgcmV0dXJuIHJvdXRlO1xyXG4gICAgfVxyXG4gICAgLy90aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBjb250ZW50IGluIEhUTUwgaXMgYSBzdHJpbmcgaW50ZXJwb2xhdGlvbiBiaW5kZXIgXHJcbiAgICBmdW5jdGlvbiBfaXNCaW5kZXIoY29udGVudCkge1xyXG4gICAgICAgIHJldHVybiBjb250ZW50LmluZGV4T2YoJ3snKSA+IC0xICYmIGNvbnRlbnQubGFzdEluZGV4T2YoJ30nKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgLy9FdmVudCBtZXRob2QgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgdHlwZXMgc29tZXRoaW5nIGluIGEgbGliLW1vZGVsIGZpZWxkXHJcbiAgICBmdW5jdGlvbiBfY2hhbmdlQ29udGVudChldmVudCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZSxcclxuICAgICAgICAgICAgYXR0clZhbHVlID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXNbJ2xpYi1tb2RlbCddLnZhbHVlLFxyXG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoYmluZGVycy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGFyZSBubyBiaW5kZXJzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRlckF0dHJWYWx1ZSA9IGJpbmRlcnNbaV0uYXR0cmlidXRlc1snbGliLWJpbmQnXS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiaW5kZXJBdHRyVmFsdWUgPT09IGF0dHJWYWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJpbmRlcnNbaV0udGV4dENvbnRlbnQgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZm91bmQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBhcmUgbm8gYmluZGVycyB3aXRoIHsnICsgYXR0clZhbHVlICsgJ30gbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvL215TGliIFBST1RPVFlQRSBmdW5jdGlvbnNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBteUxpYi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGF0YSBiaW5kIGZlYXR1cmU6IHJlY2VpdmVzIGFuIG9iamVjdCBmcm9tIHRoZSBjb250cm9sbGVyIGFuZCBzeW5jIGl0cyBwcm9wZXJ0aWVzIHdpdGggdGhlIGJpbmQgZWxlbWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBiaW5kOiBmdW5jdGlvbih2YWx1ZXMpIHtcclxuICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgYW55IGlucHV0IGZpZWxkIGxpYi1tb2RlbCwgYXR0YWNoIGFuIGV2ZW50IHRvIGNoYW5nZSBhIGxpYi1iaW5kZXIgY29udGVudFxyXG4gICAgICAgICAgICBpZiAobW9kZWxzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbW9kZWxzLmZvckVhY2goZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIF9jaGFuZ2VDb250ZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnRpZXMgaW4gdmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlclZhbHVlID0gX2lzQmluZGVyKGJpbmRlcnNbaV0udGV4dENvbnRlbnQpID8gYmluZGVyc1tpXS50ZXh0Q29udGVudC5zbGljZSgxLCBiaW5kZXJzW2ldLnRleHRDb250ZW50Lmxhc3RJbmRleE9mKCd9JykpIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IGJpbmRlclZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRlcnNbaV0udGV4dENvbnRlbnQgPSB2YWx1ZXNbcHJvcGVydGllc107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IGNyZWF0ZXMgYSByb3V0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gcjogcm91dGVzIGFycmF5XHJcbiAgICAgICAgICogLyoqXHJcbiAgICAgICAgICogUm91dGVzIHN0cnVjdHVyZSAgXHJcbiAgICAgICAgICogW1xyXG4gICAgICAgICAqICB7XHJcbiAgICAgICAgICogICAgIHBhdGg6ICcvJyxcclxuICAgICAgICAgKiAgICAgbmFtZTogJ0hvbWUnLFxyXG4gICAgICAgICAqICAgICB0ZW1wbGF0ZTogJzxwPkhvbWUgcm91dGU8L3A+J1xyXG4gICAgICAgICAqICB9LFxyXG4gICAgICAgICAqICB7XHJcbiAgICAgICAgICogICAgIHBhdGg6ICcvY29udGFjdCcsXHJcbiAgICAgICAgICogICAgIG5hbWU6ICdDb250YWN0JyxcclxuICAgICAgICAgKiAgICAgdGVtcGxhdGU6ICc8cD5Ib21lIHJvdXRlPC9wPidcclxuICAgICAgICAgKiAgfVxyXG4gICAgICAgICAqIF1cclxuICAgICAgICAgKi9cclxuICAgICAgICByb3V0ZXI6IGZ1bmN0aW9uKHJvdXRlcykge1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgY3VycmVudCBwYXRoICBnbG9iYWwgPSB3aW5kb3dcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gZ2xvYmFsLmxvY2F0aW9uLnBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgLy9jYXB0dXJlIGFsbCB0aGUgYnV0dG9ucyB3aXRoIHJvdXRlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVJvdXRlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2xpYi1yb3V0ZV0nKSk7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbmV3IFJvdXRlciBvYmplY3RcclxuICAgICAgICAgICAgZ2xvYmFsLnJvdXRlciA9IG5ldyBSb3V0ZXIocm91dGVzKTtcclxuICAgICAgICAgICAgLy9pZiB0aGVyZSBhcmUgYW55IGJ1dHRvbnMsIGFkZCBhbiBFdmVudCBsaXN0ZW5lciB0byBlYWNoIG9uZSBvZiB0aGVtXHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVSb3V0ZXMubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGFjdGl2ZVJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGl2ZVJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlUm91dGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfbmF2aWdhdGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vaWYgbm90LCBsb2cgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xyXG4gICAgICAgICAgICAgICAgbXlMaWIucHJvdG90eXBlLmxvZygnTm8gcm91dGUgYXR0cmlidXRlIGZvdW5kIScpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0lmIHRoZSBjdXJyZW50IHBhdGggaXMgJy8nIC4uLiByZW5kZXIgdGhlIEhvbWUgdGVtcGxhdGVcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgIC8vdXNlIGZpbHRlciBmZWF0dXJlIHRvIGdldCB0aGUgY3VycmVudCB0ZW1wbGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlID0gX21hdGNoV2l0aFBhdGgoY3VycmVudFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgX3NldEFjdGl2ZShyb3V0ZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZS50ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9nZXRUZW1wbGF0ZShyb3V0ZS50ZW1wbGF0ZVVybCwgZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIGhhcyBvY2N1cmVkICcsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW5uZXJIVE1MICs9IHJvdXRlLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vRWxzZSBsb29rIGZvciB0aGUgcmlnaHQgcGF0aCBhbmQgcmVuZGVyIHRoZSBjb3JyZWN0IHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSBfbWF0Y2hXaXRoUGF0aChjdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgICAgICBfc2V0QWN0aXZlKHJvdXRlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgPSAnPHN0cm9uZz4nICsgY3VycmVudFBhdGggKyAnICcgKyByb3V0ZS5uYW1lICsgJyByb3V0ZTwvc3Ryb25nPidcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZS50ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9nZXRUZW1wbGF0ZShyb3V0ZS50ZW1wbGF0ZVVybCwgZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIGhhcyBvY2N1cmVkICcsIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW5uZXJIVE1MICs9IHJvdXRlLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXAgdGhyb3VnaCBhbiBhcnJheSBhbmQgYnVpbGQgYW4gPGgzPiBlbGVtZW50IGZvciBldmVyeSBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1hcFRvRWxlbWVudDogZnVuY3Rpb24oYXIsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy9JZiBubyBhcnJheSBpcyBmb3VuZCwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgaWYgKCFhcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGRvZXMgbm90IGV4aXN0IScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vIEVsZW1lbnQgd2FzIHBhc3NlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVHJhdmVyc2UgYXJyYXkgdG8gbWFwXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGFjdHVhbCBlbGVtZW50IGlzIGFuIFVzZXIgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJbaV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3ByaW50IGtleSB2YWx1ZXMgYW5kIGl0cyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgKz0gJzxoMz5PYmplY3Q6IDwvaDM+JztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MICs9ICc8aDU+JyArIHByb3AgKyAnOiAnICsgYXJbcHJvcF0gKyAnPC9oNT4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCBpc24ndCBhbiBVc2VyIG9iamVjdCwganVzdCBwcmludCB0aGUgZWxlbWVudCBpdHNlbGZcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCArPSAnPGgzPicgKyBhcltpXSArICc8L2gzPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGdpdmVuIGFycmF5XHJcbiAgICAgICAgICogQHBhcmFtIGFyIDogQXJyYXkgT2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWF4OiBmdW5jdGlvbihhcikge1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gYXJbMF0sXHJcbiAgICAgICAgICAgICAgICAvL2dldCBhbnkgZWxlbWVudCB3aXRoIElEICNjb250ZW50XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250ZW50XCIpIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8vdHJhdmVyc2UgdGhlIGFycmF5IHRvIGZpbmQgdGhlIG1heGltdW0gdmFsdWVcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgaW5kZXggZWxlbWVudCBpcyBub3QgYSBudW1iZXIsIHRocm93IGFuIGVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyW2ldICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdUaGVyZSBhcmUgbm9uIG51bWJlciBlbGVtZW50cyBpbiB0aGUgYXJyYXkhJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgbWF4aW11bSB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4IDwgYXJbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gYXJbaV0gLy9zZXQgbWF4aW11bVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgLy9hZGQgYSByZXByZXNlbnRhdGlvbiBmb3IgdGhlIGFycmF5IHRvIHRoZSBIVE1MXHJcbiAgICAgICAgICAgICAgICBjb250ZW50LmlubmVySFRNTCArPSAnPHN0cm9uZz5UaGUgbWF4aW11bSBudW1iZXIgZnJvbSB0aGUgYXJyYXk6ICcgKyBhciArICcgaXM6ICcgKyBtYXggKyAnPC9zdHJvbmc+J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXg7IC8vIHJldHVybiB0aGUgdmFsdWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZyBtZXRob2RcclxuICAgICAgICAgKi9cclxuICAgICAgICBsb2c6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCc+PicpO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwcm9wICsgJzogJyArIGNvbnRlbnRbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0+ICcgKyBjb250ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgbm8gYXJyYXkgb3Igc3RyaW5nIGlzIGZvdW5kLCB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY29udGVudCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJzw8Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Db25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIGxpYnJhcnlcclxuICAgIG15TGliLmluaXQgPSBmdW5jdGlvbihhcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5hciA9IGFyIHx8IG51bGw7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vQm9ycm93aW5nIHRoZSBteUxpYiBwcm90b3R5cGUgZm9yIHRoZSBteUxpYi5pbml0IHByb3RvdHlwZVxyXG4gICAgbXlMaWIuaW5pdC5wcm90b3R5cGUgPSBteUxpYi5wcm90b3R5cGU7XHJcbiAgICAvL01ha2luZyBpdCBnbG9iYWwgZm9yIGV4dGVybmFsIHVzZVxyXG4gICAgZ2xvYmFsLm15TGliID0gZ2xvYmFsLm1sID0gbXlMaWI7XHJcblxyXG5cclxufSkod2luZG93KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9Vc2VyLmpzJyk7XHJcbnJlcXVpcmUoJy4vbWFpbi5qcycpO1xyXG5yZXF1aXJlKCcuL2NvbnRyb2xsZXIuanMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL3NjcmlwdHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==