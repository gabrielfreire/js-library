/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function User(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

User.prototype.getFirstName = function() {
    return this.firstName;
}

User.prototype.getLastName = function() {
    return this.lastName;
}

User.prototype.getFullName = function() {
    return this.firstName + ' ' + this.lastName;
}

module.exports = User;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * In this file i use my library to test its features
 */
var User = __webpack_require__(0),
    users = [],
    user = new User("Bob", "Marley"),
    user2 = new User("Maria", 'Jose'),
    user3 = new User("John", "McCartney"),
    user4 = new User("Claire", "Murray"),
    content = document.getElementById("content"),
    m = ml();

users.push(user);
users.push(user2);
users.push(user3);
users.push(user4);

console.log(m);
//testing max method
var maxValue = m.max([9, 1, 3, 4, 2, 1, 320, 45, 31, 123, 5, 12332, 12, 32, 156, 776, 4])
console.log(maxValue);
//testing mapToElement
m.mapToElement(users, content);
//testing log
for (var i = 0; i < users.length; i++) {
    m.log(users[i].getFullName());
}
m.log();
//Testing routes
m.router([{
        path: '/',
        name: 'Home',
        template: '<h1>This is the Home Page</h1>'
    },
    {
        path: '/about',
        name: 'About',
        template: '<h1>This is the About Page</h1>'
    },
    {
        path: '/contact',
        name: 'Contact',
        template: '<h1>This is the Contact Page</h1>'
    }
]);
//Data Binding object
var values = {
    name: 'Gabriel',
    age: 27,
    surname: 'Freire'
}

m.bind(values);

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

(function(global) {
    /**
     * Extremely simple and dump mini library for study purposes only
     * Feel free to add features and maybe transform it in something great/useful some day
     */
    "use strict";
    //---------------------------
    //Global variable declarations
    //---------------------------
    //Default view for the router feature
    var User = __webpack_require__(0),
        view = document.querySelector('[lib-view]') || '',
        binders = Array.from(document.querySelectorAll('[lib-bind]')),
        //new an Object
        myLib = function(ar) { return new myLib.init(ar); },
        Router = function(routes) { this.routes = routes; };

    //---------------------------
    //General METHODS
    //---------------------------
    //This method will change the browse location path to match with the attribute value of the button
    function _navigate(event) {
        console.log(event.target.attributes);
        //get the current path  global = window
        var currentPath = global.location.pathname,
            //get the attribute value of the current button
            route = event.target.attributes['lib-route'].value,
            //compare it with the array of routes to find
            routeInfo = router.routes.filter(function(r) {
                return r.path === route;
            })[0];

        //if no route was found, 404 page
        if (!routeInfo) {

            window.history.pushState({}, '', '404');
            view.innerHTML = 'No route with this path name';
            view.innerHTML += routeInfo.template;

        } else {
            //else, push state to the browser and render the right template
            window.history.pushState({}, '', routeInfo.path);
            view.innerHTML = 'You clicked ' + routeInfo.name + ' route';
            view.innerHTML += routeInfo.template;

        }
    };
    //this method receives a path and match with the routes array
    function _matchWithPath(currentPath) {
        var route = router.routes.filter(function(r) { return r.path === currentPath; })[0];
        return route;
    }
    //this method will return true if the content in HTML is a string interpolation binder 
    function _isBinder(content) {
        return content.indexOf('{') > -1 && content.lastIndexOf('}') > -1;
    }
    //------------------------
    //myLib PROTOTYPE functions
    //------------------------
    myLib.prototype = {
        /**
         * Data bind feature: receives an object from the controller and sync its properties with the bind elements
         */
        bind: function(values) {
            for (var properties in values) {
                for (var i = 0; i < binders.length; i++) {
                    var binderValue = _isBinder(binders[i].textContent) ? binders[i].textContent.slice(1, binders[i].textContent.lastIndexOf('}')) : null;
                    if (properties === binderValue) {
                        binders[i].textContent = values[properties];
                    }
                }
            }
        },
        /**
         * Method that creates a router
         * @param r: routes array
         * /**
         * Routes structure  
         * [
         *  {
         *     path: '/',
         *     name: 'Home',
         *     template: '<p>Home route</p>'
         *  },
         *  {
         *     path: '/contact',
         *     name: 'Contact',
         *     template: '<p>Home route</p>'
         *  }
         * ]
         */
        router: function(r) {
            //get the current path  global = window
            var currentPath = global.location.pathname,
                //capture all the buttons with route attributes
                activeRoutes = Array.from(document.querySelectorAll('[lib-route]'));
            //create a new Router object
            global.router = new Router(r);
            //if there are any buttons, add an Event listener to each one of them
            if (activeRoutes.length > 0) {

                activeRoutes.forEach(function(route) {
                    route.addEventListener('click', _navigate, false);
                });

            } else {
                //if not, log for debugging purposes
                myLib.prototype.log('No route attribute found!');

            }
            //If the current path is '/' ... render the Home template
            if (currentPath === '/') {
                //use filter feature to get the current template according to the current path
                var route = _matchWithPath(currentPath);
                view.innerHTML += route.template;

            } else {
                //Else look for the right path and render the correct template
                var route = _matchWithPath(currentPath);
                view.innerHTML = '<strong>' + currentPath + ' ' + route.name + ' route</strong>'
                view.innerHTML += route.template;

            }
        },
        /**
         * Map through an array and build an <h3> element for every index
         * @param {array} ar 
         */
        mapToElement: function(ar, element) {
            //If no array is found, throw an error
            if (!ar) {
                console.error('Array does not exist!');
            }
            if (!element) {
                console.error('Element not selected');
            }
            //Traverse array to map
            for (var i = 0; i < ar.length; i++) {
                //check if the actual element is an User object
                if (ar[i] instanceof User) {
                    if (element)
                    //print full name
                        element.innerHTML += '<h3>Hi ' + ar[i].getFullName() + '</h3>';
                } else {
                    if (element)
                    //if it isn't an User object, just print the element itself
                        element.innerHTML += '<h3>Hi ' + ar[i] + '</h3>';
                }
            }
        },
        /**
         * Return the maximum value of a given array
         * @param ar : Array Object
         */
        max: function(ar) {
            var max = ar[0],
                //get any element with ID #content
                content = document.getElementById("content") || null;
            //traverse the array to find the maximum value
            for (var i = 0; i < ar.length; i++) {
                //if the index element is not a number, throw an error
                if (typeof ar[i] !== 'number') {
                    throw 'There are non number elements in the array!';
                } else {
                    //check if the maximum value is lower than the actual value
                    if (max < ar[i]) {
                        max = ar[i] //set maximum
                    }
                }
            }
            if (content) {
                //add a representation for the array to the HTML
                content.innerHTML += '<strong>The maximum number from the array: ' + ar + ' is: ' + max + '</strong>'
            }
            return max; // return the value
        },
        /**
         * If an array was set to the object, retrieve it
         */
        getArray: function() {
            //If no array is found, throw an error
            if (!this.ar) {
                throw 'No array was passed to the constructor!';
            }
            return this.ar;
        },
        /**
         * Log a passed array
         */
        log: function(content) {
            console.warn('>>');
            if (content) {
                if (typeof content === 'object') {
                    for (var prop in content) {
                        console.log(prop + ': ' + content[prop]);
                    }
                } else
                    console.log('-> ' + content);
            } else {
                //If no array or string is found, throw an error
                console.error('No content!');
            }
            console.warn('<<');
        }

    };

    //Constructor function for the library
    myLib.init = function(ar) {

        var self = this;
        self.ar = ar || null;

    }

    //Borrowing the myLib prototype for the myLib.init prototype
    myLib.init.prototype = myLib.prototype;
    //Making it global for external use
    global.myLib = global.ml = myLib;


})(window);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(2);
__webpack_require__(1);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzdiNTE4MmZhOGMyNTYwOTExYjgiLCJ3ZWJwYWNrOi8vLy4vanMvVXNlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2pzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vanMvc2NyaXB0cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0I7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCLEVBQUU7QUFDM0QsbUNBQW1DLHNCQUFzQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0JBQStCLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRCwrSUFBK0k7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQyxVOzs7Ozs7QUM3TkQ7QUFDQTtBQUNBLHVCIiwiZmlsZSI6InNjcmlwdHMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzN2I1MTgyZmE4YzI1NjA5MTFiOCIsImZ1bmN0aW9uIFVzZXIoZmlyc3ROYW1lLCBsYXN0TmFtZSkge1xyXG4gICAgdGhpcy5maXJzdE5hbWUgPSBmaXJzdE5hbWU7XHJcbiAgICB0aGlzLmxhc3ROYW1lID0gbGFzdE5hbWU7XHJcbn1cclxuXHJcblVzZXIucHJvdG90eXBlLmdldEZpcnN0TmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmlyc3ROYW1lO1xyXG59XHJcblxyXG5Vc2VyLnByb3RvdHlwZS5nZXRMYXN0TmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubGFzdE5hbWU7XHJcbn1cclxuXHJcblVzZXIucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maXJzdE5hbWUgKyAnICcgKyB0aGlzLmxhc3ROYW1lO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9Vc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBJbiB0aGlzIGZpbGUgaSB1c2UgbXkgbGlicmFyeSB0byB0ZXN0IGl0cyBmZWF0dXJlc1xyXG4gKi9cclxudmFyIFVzZXIgPSByZXF1aXJlKCcuL1VzZXIuanMnKSxcclxuICAgIHVzZXJzID0gW10sXHJcbiAgICB1c2VyID0gbmV3IFVzZXIoXCJCb2JcIiwgXCJNYXJsZXlcIiksXHJcbiAgICB1c2VyMiA9IG5ldyBVc2VyKFwiTWFyaWFcIiwgJ0pvc2UnKSxcclxuICAgIHVzZXIzID0gbmV3IFVzZXIoXCJKb2huXCIsIFwiTWNDYXJ0bmV5XCIpLFxyXG4gICAgdXNlcjQgPSBuZXcgVXNlcihcIkNsYWlyZVwiLCBcIk11cnJheVwiKSxcclxuICAgIGNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRlbnRcIiksXHJcbiAgICBtID0gbWwoKTtcclxuXHJcbnVzZXJzLnB1c2godXNlcik7XHJcbnVzZXJzLnB1c2godXNlcjIpO1xyXG51c2Vycy5wdXNoKHVzZXIzKTtcclxudXNlcnMucHVzaCh1c2VyNCk7XHJcblxyXG5jb25zb2xlLmxvZyhtKTtcclxuLy90ZXN0aW5nIG1heCBtZXRob2RcclxudmFyIG1heFZhbHVlID0gbS5tYXgoWzksIDEsIDMsIDQsIDIsIDEsIDMyMCwgNDUsIDMxLCAxMjMsIDUsIDEyMzMyLCAxMiwgMzIsIDE1NiwgNzc2LCA0XSlcclxuY29uc29sZS5sb2cobWF4VmFsdWUpO1xyXG4vL3Rlc3RpbmcgbWFwVG9FbGVtZW50XHJcbm0ubWFwVG9FbGVtZW50KHVzZXJzLCBjb250ZW50KTtcclxuLy90ZXN0aW5nIGxvZ1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IHVzZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBtLmxvZyh1c2Vyc1tpXS5nZXRGdWxsTmFtZSgpKTtcclxufVxyXG5tLmxvZygpO1xyXG4vL1Rlc3Rpbmcgcm91dGVzXHJcbm0ucm91dGVyKFt7XHJcbiAgICAgICAgcGF0aDogJy8nLFxyXG4gICAgICAgIG5hbWU6ICdIb21lJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJzxoMT5UaGlzIGlzIHRoZSBIb21lIFBhZ2U8L2gxPidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgcGF0aDogJy9hYm91dCcsXHJcbiAgICAgICAgbmFtZTogJ0Fib3V0JyxcclxuICAgICAgICB0ZW1wbGF0ZTogJzxoMT5UaGlzIGlzIHRoZSBBYm91dCBQYWdlPC9oMT4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHBhdGg6ICcvY29udGFjdCcsXHJcbiAgICAgICAgbmFtZTogJ0NvbnRhY3QnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnPGgxPlRoaXMgaXMgdGhlIENvbnRhY3QgUGFnZTwvaDE+J1xyXG4gICAgfVxyXG5dKTtcclxuLy9EYXRhIEJpbmRpbmcgb2JqZWN0XHJcbnZhciB2YWx1ZXMgPSB7XHJcbiAgICBuYW1lOiAnR2FicmllbCcsXHJcbiAgICBhZ2U6IDI3LFxyXG4gICAgc3VybmFtZTogJ0ZyZWlyZSdcclxufVxyXG5cclxubS5iaW5kKHZhbHVlcyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9jb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIC8qKlxyXG4gICAgICogRXh0cmVtZWx5IHNpbXBsZSBhbmQgZHVtcCBtaW5pIGxpYnJhcnkgZm9yIHN0dWR5IHB1cnBvc2VzIG9ubHlcclxuICAgICAqIEZlZWwgZnJlZSB0byBhZGQgZmVhdHVyZXMgYW5kIG1heWJlIHRyYW5zZm9ybSBpdCBpbiBzb21ldGhpbmcgZ3JlYXQvdXNlZnVsIHNvbWUgZGF5XHJcbiAgICAgKi9cclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vR2xvYmFsIHZhcmlhYmxlIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vRGVmYXVsdCB2aWV3IGZvciB0aGUgcm91dGVyIGZlYXR1cmVcclxuICAgIHZhciBVc2VyID0gcmVxdWlyZSgnLi9Vc2VyLmpzJyksXHJcbiAgICAgICAgdmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tsaWItdmlld10nKSB8fCAnJyxcclxuICAgICAgICBiaW5kZXJzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbGliLWJpbmRdJykpLFxyXG4gICAgICAgIC8vbmV3IGFuIE9iamVjdFxyXG4gICAgICAgIG15TGliID0gZnVuY3Rpb24oYXIpIHsgcmV0dXJuIG5ldyBteUxpYi5pbml0KGFyKTsgfSxcclxuICAgICAgICBSb3V0ZXIgPSBmdW5jdGlvbihyb3V0ZXMpIHsgdGhpcy5yb3V0ZXMgPSByb3V0ZXM7IH07XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vR2VuZXJhbCBNRVRIT0RTXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9UaGlzIG1ldGhvZCB3aWxsIGNoYW5nZSB0aGUgYnJvd3NlIGxvY2F0aW9uIHBhdGggdG8gbWF0Y2ggd2l0aCB0aGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBidXR0b25cclxuICAgIGZ1bmN0aW9uIF9uYXZpZ2F0ZShldmVudCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzKTtcclxuICAgICAgICAvL2dldCB0aGUgY3VycmVudCBwYXRoICBnbG9iYWwgPSB3aW5kb3dcclxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSBnbG9iYWwubG9jYXRpb24ucGF0aG5hbWUsXHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgYnV0dG9uXHJcbiAgICAgICAgICAgIHJvdXRlID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXNbJ2xpYi1yb3V0ZSddLnZhbHVlLFxyXG4gICAgICAgICAgICAvL2NvbXBhcmUgaXQgd2l0aCB0aGUgYXJyYXkgb2Ygcm91dGVzIHRvIGZpbmRcclxuICAgICAgICAgICAgcm91dGVJbmZvID0gcm91dGVyLnJvdXRlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIucGF0aCA9PT0gcm91dGU7XHJcbiAgICAgICAgICAgIH0pWzBdO1xyXG5cclxuICAgICAgICAvL2lmIG5vIHJvdXRlIHdhcyBmb3VuZCwgNDA0IHBhZ2VcclxuICAgICAgICBpZiAoIXJvdXRlSW5mbykge1xyXG5cclxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgJzQwNCcpO1xyXG4gICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9ICdObyByb3V0ZSB3aXRoIHRoaXMgcGF0aCBuYW1lJztcclxuICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgKz0gcm91dGVJbmZvLnRlbXBsYXRlO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2Vsc2UsIHB1c2ggc3RhdGUgdG8gdGhlIGJyb3dzZXIgYW5kIHJlbmRlciB0aGUgcmlnaHQgdGVtcGxhdGVcclxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgcm91dGVJbmZvLnBhdGgpO1xyXG4gICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9ICdZb3UgY2xpY2tlZCAnICsgcm91dGVJbmZvLm5hbWUgKyAnIHJvdXRlJztcclxuICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgKz0gcm91dGVJbmZvLnRlbXBsYXRlO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy90aGlzIG1ldGhvZCByZWNlaXZlcyBhIHBhdGggYW5kIG1hdGNoIHdpdGggdGhlIHJvdXRlcyBhcnJheVxyXG4gICAgZnVuY3Rpb24gX21hdGNoV2l0aFBhdGgoY3VycmVudFBhdGgpIHtcclxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXIucm91dGVzLmZpbHRlcihmdW5jdGlvbihyKSB7IHJldHVybiByLnBhdGggPT09IGN1cnJlbnRQYXRoOyB9KVswXTtcclxuICAgICAgICByZXR1cm4gcm91dGU7XHJcbiAgICB9XHJcbiAgICAvL3RoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGNvbnRlbnQgaW4gSFRNTCBpcyBhIHN0cmluZyBpbnRlcnBvbGF0aW9uIGJpbmRlciBcclxuICAgIGZ1bmN0aW9uIF9pc0JpbmRlcihjb250ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuaW5kZXhPZigneycpID4gLTEgJiYgY29udGVudC5sYXN0SW5kZXhPZignfScpID4gLTE7XHJcbiAgICB9XHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9teUxpYiBQUk9UT1RZUEUgZnVuY3Rpb25zXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbXlMaWIucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERhdGEgYmluZCBmZWF0dXJlOiByZWNlaXZlcyBhbiBvYmplY3QgZnJvbSB0aGUgY29udHJvbGxlciBhbmQgc3luYyBpdHMgcHJvcGVydGllcyB3aXRoIHRoZSBiaW5kIGVsZW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmluZDogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnRpZXMgaW4gdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyVmFsdWUgPSBfaXNCaW5kZXIoYmluZGVyc1tpXS50ZXh0Q29udGVudCkgPyBiaW5kZXJzW2ldLnRleHRDb250ZW50LnNsaWNlKDEsIGJpbmRlcnNbaV0udGV4dENvbnRlbnQubGFzdEluZGV4T2YoJ30nKSkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzID09PSBiaW5kZXJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXJzW2ldLnRleHRDb250ZW50ID0gdmFsdWVzW3Byb3BlcnRpZXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRoYXQgY3JlYXRlcyBhIHJvdXRlclxyXG4gICAgICAgICAqIEBwYXJhbSByOiByb3V0ZXMgYXJyYXlcclxuICAgICAgICAgKiAvKipcclxuICAgICAgICAgKiBSb3V0ZXMgc3RydWN0dXJlICBcclxuICAgICAgICAgKiBbXHJcbiAgICAgICAgICogIHtcclxuICAgICAgICAgKiAgICAgcGF0aDogJy8nLFxyXG4gICAgICAgICAqICAgICBuYW1lOiAnSG9tZScsXHJcbiAgICAgICAgICogICAgIHRlbXBsYXRlOiAnPHA+SG9tZSByb3V0ZTwvcD4nXHJcbiAgICAgICAgICogIH0sXHJcbiAgICAgICAgICogIHtcclxuICAgICAgICAgKiAgICAgcGF0aDogJy9jb250YWN0JyxcclxuICAgICAgICAgKiAgICAgbmFtZTogJ0NvbnRhY3QnLFxyXG4gICAgICAgICAqICAgICB0ZW1wbGF0ZTogJzxwPkhvbWUgcm91dGU8L3A+J1xyXG4gICAgICAgICAqICB9XHJcbiAgICAgICAgICogXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJvdXRlcjogZnVuY3Rpb24ocikge1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgY3VycmVudCBwYXRoICBnbG9iYWwgPSB3aW5kb3dcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gZ2xvYmFsLmxvY2F0aW9uLnBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgLy9jYXB0dXJlIGFsbCB0aGUgYnV0dG9ucyB3aXRoIHJvdXRlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVJvdXRlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2xpYi1yb3V0ZV0nKSk7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbmV3IFJvdXRlciBvYmplY3RcclxuICAgICAgICAgICAgZ2xvYmFsLnJvdXRlciA9IG5ldyBSb3V0ZXIocik7XHJcbiAgICAgICAgICAgIC8vaWYgdGhlcmUgYXJlIGFueSBidXR0b25zLCBhZGQgYW4gRXZlbnQgbGlzdGVuZXIgdG8gZWFjaCBvbmUgb2YgdGhlbVxyXG4gICAgICAgICAgICBpZiAoYWN0aXZlUm91dGVzLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSb3V0ZXMuZm9yRWFjaChmdW5jdGlvbihyb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX25hdmlnYXRlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIG5vdCwgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcclxuICAgICAgICAgICAgICAgIG15TGliLnByb3RvdHlwZS5sb2coJ05vIHJvdXRlIGF0dHJpYnV0ZSBmb3VuZCEnKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9JZiB0aGUgY3VycmVudCBwYXRoIGlzICcvJyAuLi4gcmVuZGVyIHRoZSBIb21lIHRlbXBsYXRlXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aCA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAvL3VzZSBmaWx0ZXIgZmVhdHVyZSB0byBnZXQgdGhlIGN1cnJlbnQgdGVtcGxhdGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhdGhcclxuICAgICAgICAgICAgICAgIHZhciByb3V0ZSA9IF9tYXRjaFdpdGhQYXRoKGN1cnJlbnRQYXRoKTtcclxuICAgICAgICAgICAgICAgIHZpZXcuaW5uZXJIVE1MICs9IHJvdXRlLnRlbXBsYXRlO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vRWxzZSBsb29rIGZvciB0aGUgcmlnaHQgcGF0aCBhbmQgcmVuZGVyIHRoZSBjb3JyZWN0IHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSBfbWF0Y2hXaXRoUGF0aChjdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmlubmVySFRNTCA9ICc8c3Ryb25nPicgKyBjdXJyZW50UGF0aCArICcgJyArIHJvdXRlLm5hbWUgKyAnIHJvdXRlPC9zdHJvbmc+J1xyXG4gICAgICAgICAgICAgICAgdmlldy5pbm5lckhUTUwgKz0gcm91dGUudGVtcGxhdGU7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXAgdGhyb3VnaCBhbiBhcnJheSBhbmQgYnVpbGQgYW4gPGgzPiBlbGVtZW50IGZvciBldmVyeSBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1hcFRvRWxlbWVudDogZnVuY3Rpb24oYXIsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy9JZiBubyBhcnJheSBpcyBmb3VuZCwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgaWYgKCFhcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXJyYXkgZG9lcyBub3QgZXhpc3QhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFbGVtZW50IG5vdCBzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVHJhdmVyc2UgYXJyYXkgdG8gbWFwXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGFjdHVhbCBlbGVtZW50IGlzIGFuIFVzZXIgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJbaV0gaW5zdGFuY2VvZiBVc2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9wcmludCBmdWxsIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgKz0gJzxoMz5IaSAnICsgYXJbaV0uZ2V0RnVsbE5hbWUoKSArICc8L2gzPic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQgaXNuJ3QgYW4gVXNlciBvYmplY3QsIGp1c3QgcHJpbnQgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MICs9ICc8aDM+SGkgJyArIGFyW2ldICsgJzwvaDM+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgZ2l2ZW4gYXJyYXlcclxuICAgICAgICAgKiBAcGFyYW0gYXIgOiBBcnJheSBPYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBtYXg6IGZ1bmN0aW9uKGFyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBhclswXSxcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGFueSBlbGVtZW50IHdpdGggSUQgI2NvbnRlbnRcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRlbnRcIikgfHwgbnVsbDtcclxuICAgICAgICAgICAgLy90cmF2ZXJzZSB0aGUgYXJyYXkgdG8gZmluZCB0aGUgbWF4aW11bSB2YWx1ZVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBpbmRleCBlbGVtZW50IGlzIG5vdCBhIG51bWJlciwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJbaV0gIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1RoZXJlIGFyZSBub24gbnVtYmVyIGVsZW1lbnRzIGluIHRoZSBhcnJheSEnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBtYXhpbXVtIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggPCBhcltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBhcltpXSAvL3NldCBtYXhpbXVtXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvL2FkZCBhIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgYXJyYXkgdG8gdGhlIEhUTUxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQuaW5uZXJIVE1MICs9ICc8c3Ryb25nPlRoZSBtYXhpbXVtIG51bWJlciBmcm9tIHRoZSBhcnJheTogJyArIGFyICsgJyBpczogJyArIG1heCArICc8L3N0cm9uZz4nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1heDsgLy8gcmV0dXJuIHRoZSB2YWx1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYW4gYXJyYXkgd2FzIHNldCB0byB0aGUgb2JqZWN0LCByZXRyaWV2ZSBpdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9JZiBubyBhcnJheSBpcyBmb3VuZCwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFyKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gYXJyYXkgd2FzIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZyBhIHBhc3NlZCBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxvZzogZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJz4+Jyk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByb3AgKyAnOiAnICsgY29udGVudFtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0+ICcgKyBjb250ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgbm8gYXJyYXkgb3Igc3RyaW5nIGlzIGZvdW5kLCB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY29udGVudCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJzw8Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Db25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIGxpYnJhcnlcclxuICAgIG15TGliLmluaXQgPSBmdW5jdGlvbihhcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5hciA9IGFyIHx8IG51bGw7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vQm9ycm93aW5nIHRoZSBteUxpYiBwcm90b3R5cGUgZm9yIHRoZSBteUxpYi5pbml0IHByb3RvdHlwZVxyXG4gICAgbXlMaWIuaW5pdC5wcm90b3R5cGUgPSBteUxpYi5wcm90b3R5cGU7XHJcbiAgICAvL01ha2luZyBpdCBnbG9iYWwgZm9yIGV4dGVybmFsIHVzZVxyXG4gICAgZ2xvYmFsLm15TGliID0gZ2xvYmFsLm1sID0gbXlMaWI7XHJcblxyXG5cclxufSkod2luZG93KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9Vc2VyLmpzJyk7XHJcbnJlcXVpcmUoJy4vbWFpbi5qcycpO1xyXG5yZXF1aXJlKCcuL2NvbnRyb2xsZXIuanMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL3NjcmlwdHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==